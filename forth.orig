from __future__ import annotations
import re
import sys
from collections.abc import Callable, Sequence
from typing import TypeAlias, cast, Optional

WORD: TypeAlias = str
POINTER: TypeAlias = int
STACK: TypeAlias = list
LITERAL: TypeAlias = int
DATA_STACK = STACK[LITERAL]
CONTROL_STRUCT = tuple[WORD, POINTER | WORD]
CONTROL_STACK = STACK[CONTROL_STRUCT]
NATIVE_XT_R = Callable[["State", list, int], Optional[POINTER]]
DEFINED_XT_R = list[NATIVE_XT_R | LITERAL | WORD]
XT_R = NATIVE_XT_R | DEFINED_XT_R
XT_C = Callable[["State", DEFINED_XT_R], None]


class State:
    def __init__(self, parent: Interpreter, input_code: str = '', prompt="... "):
        self.input_code: str = input_code
        self.ds: DATA_STACK = []
        self.control_stack: CONTROL_STACK = []
        self.heap: list[LITERAL] = [0]*20
        self.next_heap_address: int = 0
        self.words: Sequence[WORD] = []
        self.last_created_word: WORD = ''
        self.prompt: str = prompt
        self.interpreter: Interpreter = parent

    def next_word(self) -> WORD:
        while not self.words:
            if self.input_code:
                lin = self.input_code
                self.input_code = ""
            else:
                lin = input(self.prompt) + " "
            self.tokenize(lin)

        word = self.words[0]
        if word == "bye":
            raise StopIteration
        self.words = self.words[1:]
        return word

    def tokenize(self, s):
        """clip comments, split to list of words
        """
        self.words += (
            re.sub("#.*\n", "\n", s + "\n").lower().split()
        )  # Use "#" for comment to end of line


class Interpreter:

    def __init__(self, code: str):
        self.state = State(parent=self, input_code=code)

    def run(self) -> None:
        while True:
            try:
                code = self.compile()  # compile/run from user
                if code is None:
                    print(" ")
                    break
                self.execute(code)
            except ForthCompilationError as condition:
                print(condition)
                break

    def compile(self) -> DEFINED_XT_R | None:
        code: DEFINED_XT_R = []
        self.state.prompt = "Forth> "
        while 1:
            try:
                word: WORD = self.state.next_word()  # get next word
            except StopIteration:
                return None

            assert word
            c_xt: XT_C | None = compilation_tokens.get(word)  # Is there a compile time action ?
            r_xt: XT_R | None = runtime_execution_tokens.get(word)  # Is there a runtime action ?

            if c_xt:
                c_xt(self.state, code)  # run at compile time
            elif r_xt:
                if isinstance(r_xt, list):
                    code.append(xt_r_run)  # Compiled word.
                    code.append(word)  # for now do dynamic lookup
                else:
                    code.append(r_xt)  # push builtin for runtime
            else:
                # Number to be pushed onto ds at runtime
                literal = is_literal(word)
                if literal:
                    code.append(xt_r_push)
                    code.append(int(word))
                else:  # defer
                    code.append(xt_r_run)  # Change rPush to rRun
                    code.append(word)  # Assume word will be defined
            if not self.state.control_stack:  # check end of compilation
                return code
            self.state.prompt = "...    "

    def execute(self, code: DEFINED_XT_R) -> None:
        inst_ptr: POINTER = 0
        while inst_ptr < len(code):
            next_inst = code[inst_ptr]
            assert callable(next_inst)
            func: NATIVE_XT_R = cast(NATIVE_XT_R, next_inst)
            inst_ptr += 1
            assert callable(func)
            new_inst_ptr = func(self.state, code, inst_ptr)
            if new_inst_ptr is not None:
                inst_ptr = new_inst_ptr


def xt_r_add(state: State, *_) -> None:
    b = state.ds.pop()
    a = state.ds.pop()
    state.ds.append(a + b)


def xt_r_mul(state: State, *_) -> None:
    b = state.ds.pop()
    a = state.ds.pop()
    state.ds.append(a * b)


def xt_r_sub(state: State, *_) -> None:
    b = state.ds.pop()
    a = state.ds.pop()
    state.ds.append(a - b)


def xt_r_div(state: State, *_) -> None:
    b = state.ds.pop()
    a = state.ds.pop()
    state.ds.append(a // b)


def xt_r_eq(state: State, *_) -> None:
    b = state.ds.pop()
    a = state.ds.pop()
    state.ds.append(int(a == b))


def xt_r_gt(state: State, *_) -> None:
    b = state.ds.pop()
    a = state.ds.pop()
    state.ds.append(int(a > b))


def xt_r_lt(state: State, *_) -> None:
    b = state.ds.pop()
    a = state.ds.pop()
    state.ds.append(int(a < b))


def xt_r_swap(state: State, *_) -> None:
    a = state.ds.pop()
    b = state.ds.pop()
    state.ds.append(a)
    state.ds.append(b)


def xt_r_dup(state: State, *_) -> None:
    state.ds.append(state.ds[-1])


def xt_r_drop(state: State, *_) -> None:
    state.ds.pop()


def xt_r_over(state: State, *_) -> None:
    state.ds.append(state.ds[-2])


def xt_r_dump(state: State, *_) -> None:
    print("state.ds = %s" % state.ds)


def xt_r_dot(state: State, *_) -> None:
    print(state.ds.pop())


def xt_r_jmp(_: State, cod, p) -> POINTER:
    return cod[p]


def xt_r_jnz(state: State, cod, p) -> POINTER:
    value = state.ds.pop()
    return (cod[p], p + 1)[int(value)]


def xt_r_jz(state: State, cod, p) -> POINTER:
    return (p + 1, cod[p])[state.ds.pop() == 0]


def xt_r_run(state: State, cod: DEFINED_XT_R, p: POINTER) -> POINTER:
    word = cod[p]
    assert isinstance(word, str)
    xt_r: DEFINED_XT_R = cast(DEFINED_XT_R, runtime_execution_tokens[word])
    state.interpreter.execute(xt_r)
    return p + 1


def xt_r_push(state: State, cod, p) -> int:
    state.ds.append(cod[p])
    return p + 1


def xt_r_create(state: State, *_) -> None:
    state.last_created_word = label = state.next_word()
    # when created word is run, pushes its address
    runtime_execution_tokens[label] = [xt_r_push, state.next_heap_address]


def xt_r_does(state: State, code: DEFINED_XT_R, p: POINTER) -> POINTER:
    assert isinstance(runtime_execution_tokens[state.last_created_word], list)
    xt_r: DEFINED_XT_R = cast(DEFINED_XT_R, runtime_execution_tokens[state.last_created_word])
    xt_r += code[p:]  # rest of words belong to created words runtime
    return len(code)  # jump p over these


def xt_r_allot(state: State, *_) -> None:
    """reserve n words for last create"""
    nb_cells = state.ds.pop()
    assert isinstance(nb_cells, int)
    state.next_heap_address += nb_cells


def xt_r_at(state: State, *_) -> None:
    state.ds.append(state.heap[state.ds.pop()])  # get heap @ address


def xt_r_bang(state: State, *_) -> None:
    a = state.ds.pop()
    state.heap[a] = state.ds.pop()  # set heap @ address


def xt_r_coma(state: State, *_) -> None:  # push tos into heap
    state.heap[state.next_heap_address] = state.ds.pop()
    state.next_heap_address += 1


runtime_execution_tokens: dict[str, XT_R] = {
    "+": xt_r_add,
    "-": xt_r_sub,
    "/": xt_r_div,
    "*": xt_r_mul,
    "over": xt_r_over,
    "dup": xt_r_dup,
    "swap": xt_r_swap,
    ".": xt_r_dot,
    "dump": xt_r_dump,
    "drop": xt_r_drop,
    "=": xt_r_eq,
    ">": xt_r_gt,
    "<": xt_r_lt,
    ",": xt_r_coma,
    "@": xt_r_at,
    "!": xt_r_bang,
    "allot": xt_r_allot,
    "create": xt_r_create,
    "does>": xt_r_does,
}


# ================================= Compile time


def is_literal(word: str) -> bool:
    try:
        int(word)
        return True
    except ValueError:
        pass
    return False


class ForthCompilationError(BaseException):
    pass


def fatal(msg: str) -> None:
    raise ForthCompilationError(msg)


def xt_c_colon(state: State, _) -> None:
    if state.control_stack:
        fatal(": inside Control stack: %s" % state.control_stack)
    label = state.next_word()
    state.control_stack.append(("COLON", label))  # flag for following ";"


def xt_c_semi(state: State, code: DEFINED_XT_R) -> None:
    if not state.control_stack:
        fatal("No : for ; to match")
    word, label = state.control_stack.pop()
    if word != "COLON":
        fatal(": not balanced with ;")
    assert isinstance(label, str)
    runtime_execution_tokens[label] = code[:]  # Save word definition in rDict
    while code:
        code.pop()


def xt_c_begin(state: State, code: DEFINED_XT_R) -> None:
    state.control_stack.append(("BEGIN", len(code)))  # flag for following UNTIL


def xt_c_until(state: State, code: DEFINED_XT_R) -> None:
    if not state.control_stack:
        fatal("No BEGIN for UNTIL to match")
    word, slot = state.control_stack.pop()
    if word != "BEGIN":
        fatal("UNTIL preceded by %s (not BEGIN)" % word)
    code.append(xt_r_jz)
    code.append(slot)


def xt_c_if(state: State, code: DEFINED_XT_R) -> None:
    code.append(xt_r_jz)
    state.control_stack.append(("IF", len(code)))  # flag for following Then or Else
    code.append(0)  # slot to be filled in


def xt_c_else(state: State, code: DEFINED_XT_R) -> None:
    if not state.control_stack:
        fatal("No IF for ELSE to match")
    word, slot = state.control_stack.pop()
    if word != "IF":
        fatal("ELSE preceded by %s (not IF)" % word)
    assert isinstance(slot, POINTER)
    code.append(xt_r_jmp)
    state.control_stack.append(("ELSE", len(code)))  # flag for following THEN
    code.append(0)  # slot to be filled in
    code[slot] = len(code)  # close JZ for IF


def xt_c_then(state: State, code: DEFINED_XT_R) -> None:
    if not state.control_stack:
        fatal("No IF or ELSE for THEN to match")
    word, slot = state.control_stack.pop()
    if word not in ("IF", "ELSE"):
        fatal("THEN preceded by %s (not IF or ELSE)" % word)
    assert isinstance(slot, POINTER)
    code[slot] = len(code)  # close JZ for IF or JMP for ELSE


compilation_tokens: dict[str, XT_C] = {
    ":": xt_c_colon,
    ";": xt_c_semi,
    "if": xt_c_if,
    "else": xt_c_else,
    "then": xt_c_then,
    "begin": xt_c_begin,
    "until": xt_c_until,
}


if __name__ == "__main__":
    _input_code = ''
    if len(sys.argv) > 1:
        _input_code = open(sys.argv[1]).read()  # load start file
    interpreter = Interpreter(_input_code)
    interpreter.run()
